[
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-a/",
	"title": "The Command-Line Interface (CLI)",
	"tags": [],
	"description": "",
	"content": " Jump-Start Lets assume we have the following Java class, and we want to compile it to JavaScript and run it in the Browser:\npackage bytecodertest; public class HelloWorld { public static void main(String[] args) { System.out.println(\u0026quot;Hello World!\u0026quot;); } }  First of all, we need to compile the Java sources to a JVM class file. This is done by using the javac tool from the JDK:\njavac HelloWorld.java  Now, we have the compiled .class files. Now we can use the Bytecoder CLI to compile it to JavaScript!\nStep 1: Download the CLI from Maven central:\nwget http://central.maven.org/maven2/de/mirkosertic/bytecoder/bytecoder-cli/2019-11-25/bytecoder-cli-2019-11-25-executable.jar  Step 2: Invoke the CLI and compile to JavaScript:\njava -jar bytecoder-cli-2019-11-25-executable.jar -classpath=. -mainclass=bytecodertest.HelloWorld -builddirectory=. -backend=js -minify=false  Step 3: Create an embedding HTML document:\nNow we have a bytecoder.js file, which needs to be embedded into a HTML document. Here is a sample HTML file embedding the Bytecoder JavaScript and invoking it:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Bytecoder Test\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;bytecoder.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; console.log(\u0026quot;Init\u0026quot;); bytecoder.bootstrap(); bytecocer.initializeFileIO(); bytecoder.exports.main(); console.log(\u0026quot;Done\u0026quot;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  After opening this HTML file in a Browser you will see the \u0026ldquo;Hello World!\u0026rdquo; output in the JavaScript console log.\nBonus: Compiling to WebAssembly\nGenerating WebAssembly output is just a command line switch.\njava -jar bytecoder-cli-2019-11-25-executable.jar -classpath=. -mainclass=bytecodertest.HelloWorld -builddirectory=. -backend=wasm -minify=false  However, you need a different style of HTML embedding, which is shown here:\n\u0026lt;html\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;script src=\u0026quot;bytecoder_wasmbindings.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var bytecoderWasmFile = 'bytecoder.wasm'; var instantiated = function(result) { bytecoder.init(result.instance); bytecoder.exports.initMemory(0); bytecoder.exports.bootstrap(0); bytecoder.initializeFileIO(); // We have to activate the garbage collector! var gcInterval = 10000; var gcRunning = false; setInterval(function() { if (!gcRunning) { gcRunning = true; bytecoder.exports.GC(0); gcRunning = false; } }, gcInterval); bytecoder.exports.main(0); }; WebAssembly.instantiateStreaming(fetch(bytecoderWasmFile), bytecoder.imports).then(instantiated).catch(function(error) { var request = new XMLHttpRequest(); request.open('GET', bytecoderWasmFile); request.responseType = 'arraybuffer'; request.send(); request.onload = function() { var bytes = request.response; WebAssembly.instantiate(bytes, bytecoder.imports).then(instantiated); }; }); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt;  The WebAssembly backend includes a very simple mark and sweep garbage collector. When GC runs, the application halts ( stop the world ) and memory is scanned and freed. However, this is a very expensive process, so you maybe want to configure the garbage collector interval by hand depending an your use case. The Bytecoder GC is will be removed as soon as there is a Wasm built-in garbage collector available.\n "
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-2/page-2-a/",
	"title": "Compiling OpenCL Kernels",
	"tags": [],
	"description": "",
	"content": " Compiling JVM bytecode Kernels to OpenCL OpenCL Integration is highly experimental\n First of all, make sure to include the following dependencies:\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.mirkosertic.bytecoder\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;bytecoder.opencl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2019-11-25\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.mirkosertic.bytecoder\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;bytecoder-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2019-11-25\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependency\u0026gt;  Before we can use the OpenCL integration, we have to setup the whole OpenCL environment. An OpenCL environment can be obtained by the following code:\nimport de.mirkosertic.bytecoder.api.opencl.PlatformFactory; import de.mirkosertic.bytecoder.api.opencl.Platform; PlatformFactory theFactory = PlatformFactory.resolve(); Platform thePlatform = theFactory.createPlatform(logger,options);  The Platform instance must only be obtained once and can be cached.\nIf you have multiple GPUs or a system with NVIDIA Optimus technology, you have multiple OpenCL platform available. One for the NVIDIA GPU, and another for the embedded Intel GPU on your CPU. By default Bytecoder logs the available platforms at startup and selects the OpenCL platform with the highest number. If this does not fit, you can always add a OPENCL_PLATFORM=x to your JVM properties to set the OpenCL platform to number x.\nEvery OpenCL computation is done within an OpenCL Context. This context keeps references to compiled OpenCL programs and allocated memory per Kernel. It definitely makes sense to cache a created context. Closing and reopening of context instances forces the OpenCL runtime to recompile Kernels, which will cause a huge performance impact. Context instances are auto-closable, so they can be used with Java try-with-resource blocks.\nOpenCL Kernel instances are the workhorse of the system. They can be created by sub classing de.mirkosertic.bytecoder.api.opencl.Kernel and adding a single method to it. Here is a simple example of the whole workflow:\nPlatformFactory theFactory = PlatformFactory.resolve(); Platform thePlatform = theFactory.createPlatform(logger,options); final float[] theA = {10f, 20f, 30f, 40f}; final float[] theB = {100f, 200f, 300f, 400f}; final float[] theResult = new float[4]; try (Context theContext = thePlatform.createContext()) { theContext.compute(4, new Kernel() { public void processWorkItem() { int id = get_global_id(0); float a = theA[id]; float b = theB[id]; theResult[id] = a + b; } }); } for (int i=0; i\u0026lt;theResult.length;i++) { System.out.println(theResult[i]); }  This will print the numbers 110,220,330 and 440 at command line.\nHere is an example of the OpenCL C-Code generated for the Java Kernel from above:\n__kernel void BytecoderKernel(__global const float* val$theA, __global const float* val$theB, __global float* val$theResult) { int var1 = get_global_id(0); float var4 = val$theA[var1]; float var7 = val$theB[var1]; float var9 = var4 + var7; val$theResult[var1] = var9; return; }  "
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-4/page-4-a/",
	"title": "Intermediate Representation",
	"tags": [],
	"description": "",
	"content": "The Bytecoder internal intermediate representation is basically a directed graph. The key idea behind this is described in this paper.\nGiven this Java source code:\n@Test public void testSimpleLoop() { for (int i=0;i\u0026lt;10;i++) { } }  the following intermediate representation graph is generated (in its first, un optimized form):\nThis graph combines data flow analysis and control flow into one big graph. Using this graph makes data and control flow dependencies explicit and lays foundation for a variety of optimizations that can be performed on it to either reduce code size or improve execution speed. Optimizing the program simply becomes an optimizing the graph problem.\nThe following graph shows the further optimized version of the previous loop:\nThere are two different output styles available for generated code:\n Relooper\nThe Relooper output generator tries to recover high level control flow constructs from the intermediate representation. This step eliminates the needs of GOTO statements and thus allows generation of more natural source code, which in turn can be easier read and optimized by Web Browsers or other tools. The Relooper supports all styles of control flows and also supports exception handling.\n Stackifier\n  The Stackifier is based on this paper. It tries to remove all GOTO statements and replaces them with structured control flow elements and multi level break and continues. The Stackifier does only work for reducible control flows and also does not support exception handling. The generated output is smaller and in some cases faster compared to the Relooper output.\nRelooper output is enabled by default for JS and Wasm backends. The Stackifier can be enabled for CLI or Maven by setting preferStackifier to true as a configuration parameter. If Stackifier is enabled and Bytecoder detects an irreducible control flow Relooper is used as a fallback.\nStackifier is used as the default by the OpenCL backend.\n"
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-3/page-3-a/",
	"title": "Java Box2D simulation",
	"tags": [],
	"description": "",
	"content": " A JBox2D simulation transpiled to JavaScript and WebAssembly JBox2D Demo compiled from Java to JavaScript Relooper Codegen vs. Stackifier Codegen\nJBox2D Demo compiled from Java to WebAssembly Relooper Codegen vs. Stackifier Codegen\n"
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-1/",
	"title": "Compiling JVM Bytecode",
	"tags": [],
	"description": "",
	"content": " Chapter 1 Compiling JVM Bytecode to JavaScript or WebAssembly Here you will find some tutorials about compiling JVM Bytecode to JavaScript or WebAssembly.\n"
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-3/page-3-b/",
	"title": "Kotlin JBox2D simulation",
	"tags": [],
	"description": "",
	"content": " A JBox2D simulation transpiled to JavaScript and WebAssembly JBox2D Demo compiled from Kotlin to JavaScript\nJBox2D Demo compiled from Kotlin to WebAssembly\n"
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-b/",
	"title": "The Maven Plugin",
	"tags": [],
	"description": "",
	"content": " Maven Plugin usage Bytecoder comes with a handy Maven plugin. This plugins supports the JavaScript and WebAssembly backends and can compile JVM bytecode as part of the Maven project lifecycle without any third party or command-line tools.\nConfiguration options The following configuration options are available:\n buildDirectory': The build target directory. Defaults to${project.build.outputDirectory}`\n mainClass The Classname with the main class to be compiled. Required.\n backend: The Backend to be used. Can be js or wasm. Defaults to js.\n debugOutput: Shall debug output be generated? Defaults to false.\n enableExceptionHandling: Shall Exception-Handling be activated? Defaults to false.\n optimizationLevel: Which kind of optimization should be applied? Can be NONE, ALL or EXPERIMENTAL. Defaults to ALL.\n filenamePrefix: Prefix of the generated files. Defaults to bytecoder.\n wasmInitialPages: Minimum number of pages for WASM memory. Defaults to 512.\n wasmMaximumPages: Maximum number of pages for WASM memory. Defaults to 1024.\n minifyCompileResult: Shall the compile result be minified? Defaults to true.\n preferStackifier: Shall the Stackifier be used and the Relooper as fallback? Defaults to false.\n registerAllocator: Which register allocator should be used? Can be linear or passthru? Defaults to linear.\n additionalClassesToLink: List of full qualified class names to be linked beside the statically referenced ones to make them available by reflection API. Optional\n  Compiling to JavaScript \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;de.mirkosertic.bytecoder\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;bytecoder-mavenplugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2019-11-25\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;mainClass\u0026gt;de.mirkosertic.bytecoder.integrationtest.SimpleMainClass\u0026lt;/mainClass\u0026gt; \u0026lt;backend\u0026gt;js\u0026lt;/backend\u0026gt; \u0026lt;enableExceptionHandling\u0026gt;true\u0026lt;/enableExceptionHandling\u0026gt; \u0026lt;optimizationLevel\u0026gt;ALL\u0026lt;/optimizationLevel\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;compile\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt;  You have to set a main class with a valid public static void main(String[] args) method as an entry point. The plugin will invoke the JavaScript compiler which will do all the heavy lifting. The generated JavaScript will be placed in the Maven target/bytecoder directory.\nCompiling to WebAssembly \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;de.mirkosertic.bytecoder\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;bytecoder-mavenplugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2019-11-25\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;mainClass\u0026gt;de.mirkosertic.bytecoder.integrationtest.SimpleMainClass\u0026lt;/mainClass\u0026gt; \u0026lt;backend\u0026gt;wasm\u0026lt;/backend\u0026gt; \u0026lt;enableExceptionHandling\u0026gt;false\u0026lt;/enableExceptionHandling\u0026gt; \u0026lt;optimizationLevel\u0026gt;ALL\u0026lt;/optimizationLevel\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;compile\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt;  You have to set a main class with a valid public static void main(String[] args) method as an entry point. The plugin will invoke the WebAssembly compiler which will do all the heavy lifting. The generated WebAssembly text file and compiled binaries will be placed in the Maven target/bytecoder directory.\n"
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-4/page-4-b/",
	"title": "WebAssembly Memory Management",
	"tags": [],
	"description": "",
	"content": " The WebAssembly backend emulates high level data types using WebAssembly primitives. At the moment only i32 and f32 types. All other data types are composed using data blocks in the linear memory and pointers, which are basically also i32. This Backend does not use Wasm64.\nMemory The memory is managed. It is dynamically allocated and automatically freed using a Mark-and-Sweep garbage collector. All memory is directly mapped to the Wasm linear memory.\nMemory is split into Heap and Stack. The Heap is used for allocated objects. The Stack is used to hold activation records used during method invocation.\nHeap and Stack grow in opposite directions. Heap grows from bottom to top of the linear memory. Stack grows from top to bottom. The heap contains a lot of live and dead objects and tends to be fragmented. Stack grows and shrinks with a compile time detected rates, and cannot fragment, as it is basically a stack of activation records.\nObjects Objects are a pointer to an allocated memory block. This memory contains an object header and an object body. The object header contains the following fields:\n   Field Type Description     type i32 Reference to the runtime class of this object   vtable i32 The virtual method resolver function    The object body contains the raw data of the object depending on its type.\nRuntime classes Runtime classes are objects of type runtime class and a fixed virtual table. Their object body contains the following fields:\n   Field Type Description     initstatus i32 The initialization status of the runtime class   enumvals i32 Pointer to optional enum values array   classname i32 Pointer to the class name string objectg   typeid i32 Internal unique id of this runtime class    Static class attributes are added to the field list on demand.\nArrays Arrays are objects of type array and a fixed virtual table. Their object body contains the following fields:\n   Field Type Description     length i32 The length of the array   1..length i32 Pointer for every array element    Regular object instances The object body is a list of instance members. The object body is constructed as written above.\n"
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/",
	"title": "Bytecoder User Manual",
	"tags": [],
	"description": "",
	"content": " Bytecoder User Manual Introduction Bytecoder is a Rich Domain Model for Java Bytecode and Framework to interpret and transpile it to other languages such as JavaScript, OpenCL or WebAssembly.\nIts key features are:\n Ability to cross-compile JVM Bytecode to JavaScript, WebAssembly, OpenCL and other languages Primary compile targets are JavaScript and WebAssembly Work well with Debugger Toolchains and SourceMaps Use OpenJDK 12 as Java Classlib  The JVM Bytecode is parsed and transformed into an intermediate representation. This intermediate representation is passed thru optimizer stages and sent to a backend implementation for target code generation.\nThe JavaScript backend transforms the intermediate representation into JavaScript.\nThe WebAssembly backend transforms the intermediate representation into WebAssembly text and binary code.\nThe OpenCL backend is used to compile single algorithms into OpenCL and execute them on the GPU. This backend is designed to enhance existing programs running on the JVM to utilize the vast power of modern GPUs.\n"
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-2/",
	"title": "Using the OpenCL backend",
	"tags": [],
	"description": "",
	"content": " Chapter 2 Compiling Java Kernels to OpenCL and use GPU acceleration Here we will show you how to write kernels in Java and compile them transparently to OpenCL kernels.\n"
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-c/",
	"title": "JRE Emulation",
	"tags": [],
	"description": "",
	"content": " JRE Emulation Bytecoder comes with a JRE emulation layer which is based on OpenJDK and also a set of additional libraries for browser interaction, vue.js and OpenCL integration.\nBytecoder comes with a set of JPMS modules like java.base etc. Please note that Bytecoder does not support the JPMS in general. From the compiler and runtime view, all classes are exported to the ALL-UNNAMED module by default, module-info declarations are completely ignored.\n bytecoder-core Bytecoder-core includes the compiler Logic and the JUnit Testrunner. Most of the time you won\u0026rsquo;t need this module directly, as it is included in the CLI and the Maven Plugin by default.\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.mirkosertic.bytecoder\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;bytecoder-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2019-11-25\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependency\u0026gt;  bytecoder.api Bytecoder.api provides a set of Classes and Annotations which enables the Compiler do its job.\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.mirkosertic.bytecoder\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;bytecoder.api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2019-11-25\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependency\u0026gt;  java.base Java.base contains the java.base JPMS Module.\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.mirkosertic.bytecoder\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;java.base\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2019-11-25\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependency\u0026gt;  java.xml Java.xml contains the java.xml JPMS Module.\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.mirkosertic.bytecoder\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;java.xml\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2019-11-25\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependency\u0026gt;  java.datatransfer Java.datatransfer contains the java.datatransfer JPMS Module.\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.mirkosertic.bytecoder\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;java.datatransfer\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2019-11-25\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependency\u0026gt;  java.desktop Java.desktop contains the java.desktop JPMS Module.\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.mirkosertic.bytecoder\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;java.desktop\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2019-11-25\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependency\u0026gt;  bytecoder.web Bytecoder.web contains APIs to interact with the Browser.\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.mirkosertic.bytecoder\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;bytecoder.web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2019-11-25\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependency\u0026gt;  bytecoder.vue Bytecoder.vue allows vue.js enabled frontends using Bytecoder.\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.mirkosertic.bytecoder\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;bytecoder.vue\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2019-11-25\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependency\u0026gt;  bytecoder.opencl Bytecoder.opencl is required if you want to use the OpenCL integration.\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.mirkosertic.bytecoder\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;bytecoder.opencl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2019-11-25\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependency\u0026gt;  "
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-3/page-3-c/",
	"title": "Lua4J interpreter",
	"tags": [],
	"description": "",
	"content": " The Lua4J interpreter transpiled to JavaScript and WebAssembly Lua4J Demo compiled to JavaScript\nLua4J Demo compiled to WebAssembly\n"
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-4/page-4-c/",
	"title": "Optimizer effectiveness",
	"tags": [],
	"description": "",
	"content": "   Step JBox2D JS Demo JBox2D Wasm Demo     Unoptimized 2.051.489 bytes 1.226.186 bytes   Linear Register Allocation 1.582.659 bytes 1.081.372 bytes   Constant Inlining 1.487.327 bytes 1.010.403 bytes   Inefficient If-Conditions 1.473.286 bytes 1.001.294 bytes   Inefficient Field-Read 1.401.204 bytes 929.177 bytes   Inefficient Field-Write 1.370.353 bytes 909.742 bytes   Inefficient Invocations 1.261.180 bytes 857.123 bytes   Inefficient Array-Access 1.246.460 bytes 851.354 bytes   Inefficient Binary Expr. 1.175.820 bytes 818.940 bytes    Reference: 2019-08-30 build:\n   Testcase Total     JBox2D JS Demo 1.080.438 bytes   JBox2D Wasm Demo 772.196 bytes    "
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-3/",
	"title": "Examples",
	"tags": [],
	"description": "",
	"content": " Chapter 3 Example applications The following pages show you a set of example applications compiled with Bytecoder to JavaScript or WebAssembly.\n"
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-d/",
	"title": "Reflection API",
	"tags": [],
	"description": "",
	"content": " Overview Bytecoder is an AOT (Ahead-of-time) compiler. As this, it has to determine the set of classes at compile time. It does this by running a statical dependency analysis which starts at a class implementing a public static void main(String[] args) method and builds a dependency tree from there resulting in the final set of classes and methods that must be included to make the program valid.\nHowever, things start to get tricky once we use the Java Reflection API.\nThe most famous part of the Reflection API is the Class.forName method and its derivatives. Here, the class to be resolved is defined as runtime. This is a problem for an AOT compiler. Bytecoder tries so solve this problem using a set of heuristics and configuration.\nClasses that are very likely to be resolved by reflection are automatically included by the compiler. Some promiment examples are implementations of java.nio.charset.Charset or java.lang.CharacterData. There is also a compiler option available by the CLI or Maven Plugin to add additional classes.\nOnly zero-arg constructors are supported yet.\n Support for the Java Reflection API The following APIs are supported by Bytecoder:\nClass runtimeClass = Class.forName(\u0026quot;FullQualifiedClassNameHere\u0026quot;); Object instance = runtimeClass.newInstance(); // Method 1 to instantiate a class cl.getConstructor(new Class[0]).newInstance(); // Method 2 to instantiate a class  The ServiceLocator API is currently not supported!\n "
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-3/page-3-d/",
	"title": "Vue.js WebAssembly integration",
	"tags": [],
	"description": "",
	"content": " An example showing vue.js and WebAssembly integration vue.js integration Demo compiled to WebAssembly\n"
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-4/",
	"title": "Internals",
	"tags": [],
	"description": "",
	"content": " Chapter 4 Implementation internals Here you will find a lot of information about what is going on behind the scenes of Bytecoder.\n"
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-3/page-3-e/",
	"title": "Gamecomposer Gameengine",
	"tags": [],
	"description": "",
	"content": " A complex gameengine compiled to JavaScript and WebAssembly GameComposer Physics Game Example compiled to WebAssembly. GameComposer is available here\nGameComposer Physics Game Example compiled to JavaScript. GameComposer is available here\n"
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-f/",
	"title": "Interoperability",
	"tags": [],
	"description": "",
	"content": " Hello World, extended edition! Let\u0026rsquo;s see how a simple Java program can be written that changes the document title in the Browser. Here it is:\nimport de.mirkosertic.bytecoder.api.web.Event; import de.mirkosertic.bytecoder.api.web.EventListener; import de.mirkosertic.bytecoder.api.web.HTMLDocument; import de.mirkosertic.bytecoder.api.web.Window; public class OpaqueReferenceTest { public static void main(String[] args) { final Window w = Window.window(); w.document().addEventListener(\u0026quot;click\u0026quot;, new EventListener\u0026lt;ClickEvent\u0026gt;() { @Override public void run(final ClickEvent aValue) { w.document().title(\u0026quot;clicked!\u0026quot;); } }); } }  I\u0026rsquo;ll try to explain the basics behind this and how it can be compiled to JavaScript or WebAssembly in the following sections.\nInteroperability and runtime linkage Programs do not live on their own, they need to communicate with their environment. This communication can be tricky if done on multiple environments. Bytecoder supports JavaScript, WebAssembly and OpenCL as target platforms. How does this wok?\nOpaqueReferenceTypes API Bytecoder allows transparent usage of APIs not implemented by Bytecoder itself. Such APIs are provided by the host environment, for instance the DOM API or interaction with the browser window. Bytecoder support such APIs by so called OpaqueReferenceTypes. For every external API, a new OpaqueReferenceType in form of a JVM interface class needs to be created. Bytecoder already comes with implementations for the browser window and the DOM.\nSee the following example, which demonstrates calls from Bytecoder to the HTML Canvas API:\nWindow window = Window.window(); Document document = window.document(); final HTMLCanvasElement theCanvas = document.getElementById(\u0026quot;benchmark-canvas\u0026quot;); CanvasRenderingContext2D renderingContext2D = theCanvas.getContext(\u0026quot;2d\u0026quot;); renderingContext2D.moveTo(10, 10); renderingContext2D.lineTo(20, 20);  Bytecoder also supports event listeners, as seen in the following example:\nfinal HTMLElement button = document.getElementById(\u0026quot;button\u0026quot;); button.addEventListener(\u0026quot;click\u0026quot;, new EventListener\u0026lt;ClickEvent\u0026gt;() { @Override public void run(ClickEvent aValue) { button.disabled = true; } });  The OpaqueReferenceType API allows the following types for Bytecoder-Host communication:\n Primitives(int,float,double,long,char,byte,short) java.lang.String de.mirkosertic.bytecoder.api.OpaqueReferenceType and sub classes of it de.mirkosertic.bytecoder.api.Callback and sub classes of it  java.lang.String references are a special case. They are objects in the sense of the JVM, but they are not automatically converted to JavaScript String instances on host side due to the expensive conversion operation and its potential performance impact. However, there are handy conversion operations available to do it if its really needed. The conversion functions are part of the global bytecoder object as bytecoder.toJSString(aBytecoderString) and bytecoder.toBytecoderString(aJSString) respectively.\n The JVM long datatype is currently only in a limited form available in Bytecoder. There is currently no native 64-bit integer datatype available in JavaScript. Bytecoder is limited to a 53-bit range due to JavaScripts IEEE 754 double precision number type. However, once JavaScript BigInt will be supported by all major browsers, Bytecoder will use BigInt as a substitute for the JVM long datatype. For now, there is no full emulation of long datatypes planned.\n Importing functionality from the host environment Using host environment functionality is quite common. This can be either simply logging or more complex code. Basically something that cannot be archived by plain OpaqueReferenceTypes.\nJava has a built-in language feature for importing functionality. The native keyword!\nFor instance, we take a look at the TMath runtime class:\npublic class TMath extends TObject { public static native double sqrt(double aValue); }  The native keyword instructs the JVM to link the implementation code from somewhere else. This linking is done when bootstrapping the Bytecoder runtime. By default, Bytecoder will import the implementation using a modulename and an importname. The modulename is derived from the classname in lowercase, the importname is the method name to import.\nNative-Linking in JavaScript At startup, the following code must be provided:\nbytecoder.imports.math = { sqrtDOUBLE: function(p1) { return Math.sqrt(p1); }, };  Native-Linking in WebAssembly At startup, the following code must be provided:\nbytecoder.imports.math = { sqrtDOUBLE: function(thisref, p1) { return Math.sqrt(p1); }, };  Customizing the module names Sometimes you want to provide your own modulename and importname. This can be done by adding an @de.mirkosertic.bytecoder.api.Import annotation to the native method:\npublic class CanvasRenderingContext2D { @Import(module = \u0026quot;canvas\u0026quot;, name = \u0026quot;canvasClear\u0026quot;) public native void clear(); }  Exporting functionality to the host environment We also want to make functionality be callable from the host environment. The most important use case for this is to call out program! So, how can this be done? Java has no keyword that could mimic this behavior, so we have to provide our own. Method that should be callable from the host environment needs to be annotated with @de.mirkosertic.bytecoder.api.Export, as seen in the following example:\npublic class JBox2DSimulation { @Export(\u0026quot;proceedSimulation\u0026quot;) public static void proceedSimulation() { } }  Calling exported functionality from JavaScript Just call an exported method using the Bytecoder module API:\nbytecoder.exports.proceedSimulation();  Calling exported functionality from WebAssembly Easy, just call the method:\nrunningInstance.exports.proceedSimulation(0);  The WebAssembly runtime only makes @de.mirkosertic.bytecoder.api.Export annotated methods available as exports.\n"
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-e/",
	"title": "Unit Testing",
	"tags": [],
	"description": "",
	"content": " Testing code generation Bytecoder comes with built in JUnit Testing support using a specialized test runner. This test runner compiles the body of the test method to a target language and executes this code. For instance, the following JUnit Test\n@RunWith(de.mirkosertic.bytecoder.unittest.BytecoderUnitTestRunner.class) public class SimpleMathTest { public static int sum(int a, int b) { return a + b; } @Test public void testAdd() throws Exception { int c = sum(10, 20); Assert.assertEquals(20, c, 0); } }  is compiled to JavaScript and WebAssembly and executed using a Selenium Chrome driver. This test runner also supports comparison of original Java code and its cross compiled counterpart. This mechanism is the core tool to test the compiler and the Classlib.\nBytecoder relies for WebAssembly unit testing on Chrome. To make everything working, you have to add CHROMEDRIVER_BINARY environment variable pointing to an installed Selenium Chrome WebDriver binary. You can get the latest release of WebDriver here: https://sites.google.com/a/chromium.org/chromedriver.\nPlease make sure to include the following dependency to make the Testrunner working:\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.mirkosertic.bytecoder\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;bytecoder-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2019-11-25\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;B \u0026lt;/dependency\u0026gt; \u0026lt;/dependency\u0026gt;  "
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/chapter-1/page-1-g/",
	"title": "Extending the JRE",
	"tags": [],
	"description": "",
	"content": " Extending existing classes Sometimes the methods or properties you want aren\u0026rsquo;t there, but it\u0026rsquo;s very simple to add them.\npublic abstract class CustomCanvas extends de.mirkosertic.bytecoder.api.web.HTMLCanvasElement { // The following two methods are setters and getters for the canvas.width property. @de.mirkosertic.bytecoder.api.OpaqueProperty public abstract void width(float value); @de.mirkosertic.bytecoder.api.OpaqueProperty public abstract float width(); }  To use your custom methods or properties simply cast a HTMLCanvasElement to CustomCanvas.\n((CustomCanvas) Window.window().document().getElementById(\u0026quot;canvas\u0026quot;)).width(1000);  Implementing bridges for JavaScript objects and classes Explanation of JavaScript data types in this page:\n Objects are non-instantiable (e.g. window.navigator) Classes are instantiable (e.g. new ArrayBuffer(\u0026hellip;))  Objects public abstract class Navigator implements de.mirkosertic.bytecoder.api.OpaqueReferenceType { public static native Navigator navigator(); @de.mirkosertic.bytecoder.api.OpaqueProperty public abstract String userAgent(); @de.mirkosertic.bytecoder.api.OpaqueProperty public abstract boolean cookieEnabled(); // If you want to have a different name in the Java code, you can // name the method for example beaconSend and annotate it with // @OpaqueMethod(\u0026quot;sendBeacon\u0026quot;) // This specific method has more types of possible arguments, // if you need to support those you just need to add more methods // but with the other `data` types public abstract void sendBeacon(String url, String data); }  // Although the import would be created because this // class is implementing OpaqueReferenceType AND we are // calling one of it's abstract methods in our Java code, // not calling one would cause JavaScript errors. // So to be 100% sure it's better to define fallback to an // empty object. bytecoder.imports.navigator = bytecoder.imports.navigator || {}; // This method has no arguments so it's simply called navigator bytecoder.imports.navigator.navigator = function (thisref) { return bytecoder.toBytecoderReference(navigator); };  System.out.println(Navigator.navigator().userAgent());  Classes public abstract class ArrayBuffer implements OpaqueReferenceType { // The @Import annotation is completely optional and // it removes the need for having to include the // parameter types in the method name on the JavaScript side. @de.mirkosertic.bytecoder.api.Import(module = \u0026quot;arraybuffer\u0026quot;, name = \u0026quot;create\u0026quot;) public static native create(int size); @de.mirkosertic.bytecoder.api.OpaqueProperty public int byteLength(); }  // Read the comment on Objects in this section. // Native methods are not abstract and if we for example // only call ArrayBuffer.create(...) then an import would not // be created. But if we also called ArrayBuffer.byteLength() // it would, so it is much more secure to fallback to {}. bytecoder.imports.arraybuffer = bytecoder.imports.arraybuffer || {}; // Passing around objects works by references, the Java code // automatically converts this reference to an instance of // ArrayBuffer but the JavaScript bindings have no such features. // Warning: This method uses the @Import annotation which is why // it is called `create` and not `createINT`. bytecoder.imports.arraybuffer.create = function (thisref, size) { return bytecoder.toBytecoderReference(new ArrayBuffer(size)); };  System.out.println(ArrayBuffer.create(6).byteLength()); // 6  Taking classes as method parameters public abstract class DataView implements de.mirkosertic.bytecoder.api.OpaqueReferenceType { public static native create(ArrayBuffer arrayBuffer); // ... opaque methods and properties ... }  bytecoder.imports.dataview = bytecoder.imports.dataview || {}; // create - method name, ArrayBuffer - parameter type bytecoder.imports.dataview.createArrayBuffer = function (thisref, arraybufferref) { return bytecoder.toBytecoderReference(new DataView(bytecoder.toJSReference(arraybufferref))); };  Import and Export semantics  Imports are methods imported from JavaScript/Host side and called from Java. Exports are methods exported from Java and called from JavaScript/Host side.  Emulating classes and methods Bytecoder is based on the OpenJDK JRE classlib. However, it is sometimes neccesary to patch existing classes to make them compatible with Bytecoder.\nBytecoder introduces a concept called shadow types for this purpose.\nTake a look at the java.lang.System class. It needs some adaptation for make it compatible with Bytecoder. Now, the shadow type called de.mirkosertic.bytecoder.classlib.java.lang.TSystem is introduced. Shadow types need the package prefix de.mirkosertic.bytecoder.classlib and the @de.mirkosertic.bytecoder.api.SubstitutesInClass annotation.\n@SubstitutesInClass toggles what should be adapted by the shadow type. It can either override the whole class by setting completeReplace=true or only specified methods by setting completeReplace=false.\n"
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://mirkosertic.github.io/Bytecoder/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]